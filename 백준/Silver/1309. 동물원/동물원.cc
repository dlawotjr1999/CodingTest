#include <iostream>

// 어떤 동물원에 가로로 두칸 세로로 N칸인 아래와 같은 우리가 있을 때, 동물들을 우리에 가로로도 세로로도 붙어 있게 배치할 수는 없음
// 이 때, 2 * N 크기의 우리에 동물들을 배치할 수 있는 경우의 수를 구하는 문제
// 우리에 동물을 한 마리도 배치하지 않는 경우도 하나의 경우의 수로 취급함

// DP 배열은 아래와 같이 2차원으로 선언함
// 배열의 열은 0(배치하지 않음), 1(왼쪽에만 배치), 2(오른쪽에만 배치)를 의미함
int DP[100001][3];

int main() {
	int N;
	std::cin >> N;

	DP[1][0] = 1;
	DP[1][1] = 1;
	DP[1][2] = 1;

	/*
	배치할 수 있는 경우의 수는 아래와 같이 구할 수 있음

	1. 이전에 무엇도 배치하지 않은 경우 : 이번 차례에는 무엇도 배치하지 않거나, 왼쪽에만 배치하거나, 오른쪽에만 배치할 수 있음(DP[i - 1][0] + DP[i - 1][1] + DP[i - 1][2])
	2. 이전에 왼쪽에 배치한 경우 : 이번 차례에는 무엇도 배치하지 않거나, 오른쪽에만 배치할 수 있음(DP[i - 1][0] + DP[i - 1][2])
	3. 이전에 오른쪽에 배치한 경우 : 이번 차례에는 무엇도 배치하지 않거나, 왼쪽에만 배치할 수 있음(DP[i - 1][0] + DP[i - 1][1])

	위 경우들을 통해 아래와 같은 점화식들을 유도할 수 있으며, 이 경우의 수들을 모두 합한 값이 정답이 됨
	*/
	for (int i = 2; i <= N; ++i) {
		DP[i][0] = (DP[i - 1][0] + DP[i - 1][1] + DP[i - 1][2]) % 9901;
		DP[i][1] = (DP[i - 1][0] + DP[i - 1][2]) % 9901;
		DP[i][2] = (DP[i - 1][0] + DP[i - 1][1]) % 9901;
	}

	int result = (DP[N][0] + DP[N][1] + DP[N][2]) % 9901;
	std::cout << result;

	return 0;
}