#include <bits/stdc++.h>

// 아래 문제를 구현
// https://www.acmicpc.net/problem/14500

int N, M;
int answer;

int field[501][501];

// 테트로미노의 가능한 모든 모양
std::vector<std::array<std::pair<int, int>, 4>> shapes = {
	// I
	{{{0,0},{0,1},{0,2},{0,3}}},
	{{{0,0},{1,0},{2,0},{3,0}}},

	// O
	{{{0,0},{0,1},{1,0},{1,1}}},

	// T
	{{{0,0},{0,1},{0,2},{1,1}}},
	{{{0,1},{1,0},{1,1},{1,2}}},
	{{{0,1},{1,1},{2,1},{1,0}}},
	{{{0,0},{1,0},{2,0},{1,1}}},

	// S
	{{{0,0},{0,1},{1,1},{1,2}}},
	{{{1,0},{0,1},{1,1},{0,2}}},
	{{{0,0},{1,0},{1,1},{2,1}}},
	{{{0,1},{1,1},{1,0},{2,0}}},

	// L
	{{{0,0},{1,0},{2,0},{2,1}}},
	{{{0,1},{1,1},{2,1},{2,0}}},
	{{{0,0},{0,1},{0,2},{1,0}}},
	{{{0,0},{0,1},{0,2},{1,2}}},
	{{{0,0},{1,0},{1,1},{1,2}}},
	{{{0,2},{1,0},{1,1},{1,2}}},
	{{{0,0},{1,0},{2,0},{0,1}}},
	{{{0,1},{1,1},{2,1},{0,0}}},
};

// 다른 솔루션
// DFS를 통해 가능한 4칸의 모든 경우의 수를 탐색
// T자의 경우 DFS를 통해 만들 수 없으므로 예외적으로 하드코딩으로 표현

int main() {
	std::cin >> N >> M;

	for (int i = 0; i < N; ++i) {
		for (int j = 0; j < M; ++j) {
			std::cin >> field[i][j];
		}
	}
	
	// 모든 칸에 대해서 가능한 테트로미노의 모든 경우 탐색 
	for (int i = 0; i < N; ++i) {
		for (int j = 0; j < M; ++j) {
			for (auto& shape : shapes) {
				int cur = 0;
				bool isOk = true;

				// 현재 테트로미노를 이루는 각 칸 숫자들의 합 계산
				for (auto [x, y] : shape) {
					int dx = j + x, dy = i + y;

					// 범위를 벗어나는 경우에는 불가능
					if (dx < 0 || dx >= M || dy < 0 || dy >= N) {
						isOk = false;
						break;
					}

					cur += field[dy][dx];
				}

				if (isOk)
					answer = std::max(answer, cur);
			}
		}
	}

	std::cout << answer;
	return 0;
}