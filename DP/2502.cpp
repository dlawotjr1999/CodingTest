#include <iostream>

// 떡 장사 할머니는 호랑이에게 떡을 주어야만 산을 넘을 수 있다
// 호랑이는 어제 받은 떡과 그저께 받은 떡의 갯수를 더한 만큼의 떡을 받아야만 할머니를 무사히 보내준다
// 할머니가 넘어온 날과 그 날 준 떡의 갯수가 주어질 때 첫째 날과 둘째 날에 준 떡 각각의 갯수를 구하는 문제

// A[i] = i일째 날 떡 수를 계산할 때 첫째 날 떡 수가 기여하는 비율
// B[i] = i일째 날 떡 수를 계산할 때 둘째 날 떡 수가 기여하는 비율
// 즉, i일째 떡 수 = A[i]*a + B[i]*b (a: 첫째 날 떡 수, b: 둘째 날 떡 수)
int A[30];
int B[30];

int main() {
	int D, K;
	std::cin >> D >> K;

	/*
	규칙을 찾아보자
	
	- 첫째 날 : A개
	- 둘째 날 : B개
	- 셋째 날 : A + B개
	- 넷째 날 : A + 2B개
	- 다섯째 날 : 2A + 3B개
	- 여섯째 날 : 3A + 5B개

	계수만을 봤을 때 A[n] = A[n - 1] + A[n -2], B[n] = B[n - 1] + B[n -2]이다
	즉 피보나치 수열과 같은 점화식을 따름
	*/

	A[1] = 1;
	A[2] = 0;
	B[1] = 0;
	B[2] = 1;

	// 각 날짜마다 a와 b의 계수를 구함
	for (int i = 3; i <= D; i++) {
		A[i] = A[i - 1] + A[i - 2];
		B[i] = B[i - 1] + B[i - 2];
	}

	/*
	D일차의 떡 개수는 다음과 같다 :
		A[D] * a + B[D] * b = K
	이 식을 만족하는 순서쌍 (a, b)를 찾아야 함. (단, a와 b는 자연수)

	즉 A[D]*a + B[D]*b = K 를 만족하는 자연수 해를 찾는 문제
	모든 가능한 a에 대해 b = (K - A[D]*a) / B[D]가 자연수인지 확인하면 된다
	*/
	for (int i = 1; i <= K; i++) {
		int temp = K - (A[D] * i);
		if (temp % B[D] == 0) {
			if (1 <= i && i <= temp / B[D]) {
				std::cout << i << '\n' << temp / B[D] << std::endl;
				break;
			}
		}
	}

	return 0;
}