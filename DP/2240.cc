#include <bits/stdc++.h>

// 매 초마다 두 개의 나무 중 하나의 나무에서 자두가 떨어지며, 그 나무의 아래에 서 있으면 자두를 받아먹을 수 있음
// 또한 하나의 나무 아래에 서 있다가 다른 나무 아래로 빠르게 움직일 수 있음
// 자두는 T초 동안 떨어지게 되며, 최대 W번만 움직일 수 있음 
// 매 초마다 어느 나무에서 자두가 떨어질지에 대한 정보가 주어졌을 때, 받을 수 있는 자두의 최대 갯수를 구하는 문제

int answer;

// DP[i][j][k] : i초에 j번의 움직여서 k 나무에 있을 때 얻을 수 있는 자두의 최대 갯수
int DP[1001][31][2];

int main() {
	int T, W;
	std::cin >> T >> W;

	std::vector<int> vec(T + 1);
	for (int i = 1; i <= T; ++i) {
		std::cin >> vec[i];
	}

	// 시간은 1~T초, 움직임은 0~W번까지 가능
	for (int i = 1; i <= T; ++i) {
		for (int j = 0; j <= W; ++j) {
			// 움직이지 않으면 최초 위치인 1번 나무에만 위치하게 됨
			// 이러한 경우 1번 나무에서 떨어지는 자두만 받을 수 있음
			if (j == 0) {
				DP[i][0][0] = DP[i - 1][0][0] + (vec[i] == 1 ? 1 : 0);
				continue;
			}
			
			// 1번 나무에서 자두가 떨어지는 경우
			// 1번 나무에서의 DP 상태 : (i-1)초에 움직이지 않고 1번 나무에 위치하는 경우와 (i-1)초에 움직여서 1번 나무에 위치하는 경우 중 최댓값에 +1
			// 2번 나무에서의 DP 상태 : (i-1)초에 움직이지 않고 2번 나무에 위치하는 경우와 (i-1)초에 움직여서 2번 나무에 위치하는 경우 중 최댓값
			if (vec[i] == 1) {
				DP[i][j][0] = std::max(DP[i - 1][j][0], DP[i - 1][j - 1][1]) + 1;
				DP[i][j][1] = std::max(DP[i - 1][j - 1][0], DP[i - 1][j][1]);
			}

			// 2번 나무에서 자두가 떨어지는 경우
			// 1번 나무에서의 DP 상태 : (i-1)초에 움직이지 않고 1번 나무에 위치하는 경우와 (i-1)초에 움직여서 2번 나무에 위치하는 경우 중 최댓값
			// 2번 나무에서의 DP 상태 : (i-1)초에 움직이지 않고 2번 나무에 위치하는 경우와 (i-1)초에 움직여서 2번 나무에 위치하는 경우 중 최댓값에 +1
			else {
				DP[i][j][0] = std::max(DP[i - 1][j][0], DP[i - 1][j - 1][1]);
				DP[i][j][1] = std::max(DP[i - 1][j - 1][0], DP[i - 1][j][1]) + 1;
			}
		}
	}

	// T초에 0~W번 움직여서 얻을 수 있는 자두의 최댓값 갱신
	for (int w = 0; w <= W; ++w) {
		int temp = std::max(DP[T][w][0], DP[T][w][1]);
		answer = std::max(temp, answer);
	}

	std::cout << answer;
	return 0;
}